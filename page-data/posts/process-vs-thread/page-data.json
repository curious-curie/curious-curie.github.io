{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/process-vs-thread","result":{"data":{"markdownRemark":{"id":"a5843fb6-9492-5ba2-86c2-fa7e00153841","html":"<h1 id=\"프로세스-vs-쓰레드\" style=\"position:relative;\"><a href=\"#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-vs-%EC%93%B0%EB%A0%88%EB%93%9C\" aria-label=\"프로세스 vs 쓰레드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>프로세스 vs 쓰레드</h1>\n<h2 id=\"프로세스\" style=\"position:relative;\"><a href=\"#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4\" aria-label=\"프로세스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>프로세스</h2>\n<ul>\n<li>\n<p><strong>“컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램”</strong></p>\n<ul>\n<li>프로그램: 어떤 작업을 위해 실행할 수 있는 파일</li>\n</ul>\n</li>\n<li>메모리에 올라와 실행되고 있는 프로그램의 인스턴스 (독립적인 개체)</li>\n<li>\n<p>운영체제로부터 시스템 자원을 할당받는 작업의 단위</p>\n<ul>\n<li>\n<p>할당 받는 시스템 자원의 예</p>\n<p>CPU 시간</p>\n<p>운영되기 위해 필요한 주소 공간</p>\n<p>Code, Data, Stack, Heap으로 구성되어 있는 독립된 메모리 영역 </p>\n</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://gmlwjd9405.github.io/images/os-process-and-thread/process.png\" alt=\"%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%20vs%20%E1%84%8A%E1%85%B3%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%20c1cf91907f7c4527b6b8c2e38d35c52a/Untitled.png\">\n출처: <a href=\"https://gmlwjd9405.github.io/2018/09/14/process-vs-thread.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Heee’s Development Blog</a></p>\n<ul>\n<li>\n<p>프로세스는 각각 독립된 메모리 영역을 할당받는다</p>\n<ul>\n<li>Code, Data, Stack, Heap의 구조</li>\n</ul>\n</li>\n<li>기본적으로 프로세스당 최소 1개의 스레드 (메인 스레드)를 가짐</li>\n<li>각 프로세스는 별도의 주소 공간에서 실행되며, 한 프로세스는 다른 프로세스의 변수나 자료구조에 접근할 수 없음</li>\n<li>\n<p>한 프로세스가 다른 프로세스의 자원에 접근하려면 프로세스 간의 통신을 사용해야함</p>\n<ul>\n<li>e.g. 파이프, 파일, 소켓 등을 이용한 통신</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"스레드\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%EB%A0%88%EB%93%9C\" aria-label=\"스레드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스레드</h3>\n<ul>\n<li><strong>프로세스 내에서 실행되는 여러 흐름의 단위</strong></li>\n<li>프로세스의 특정한 수행 경로</li>\n<li>프로세스가 할당받은 자원을 이용하는 실행의 단위</li>\n<li>스레드는 프로세스 내에서 스택만 따로 할당받고 코드, 데이터, 힙 영역은 공유</li>\n<li>프로세스 내의 주소 공간이나 자원(힙 공간 등…)은 같은 프로세스 내의 스레드끼리 공유하면서 실행됨</li>\n<li>각각의 스레드는 별도의 레지스터, 스택 가짐. 힙 메모리는 서로 읽고 쓸 수 있다</li>\n<li>스레드끼리는 서로의 메모리 접근 가능, 프로세스는 다른 프로세스의 메모리에 직접 접근 불가능</li>\n<li>한 스레드가 프로세스의 자원을 변경하면, 다른 이웃 스레드도 그 변경 결과를 즉시 볼 수 있음</li>\n</ul>\n<h3 id=\"멀티-프로세스\" style=\"position:relative;\"><a href=\"#%EB%A9%80%ED%8B%B0-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4\" aria-label=\"멀티 프로세스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>멀티 프로세스</h3>\n<ul>\n<li>하나의 응용프로그램을 여러 개의 프로세스로 구성하여 각 프로세스가 하나의 작업을 처리하도록</li>\n<li>\n<p>장점</p>\n<ul>\n<li>여러 개의 자식 프로세스 중 하나에 문제 발생 시 그 프로세스만 죽고 다른 것에 영향 X</li>\n</ul>\n</li>\n<li>\n<p>단점</p>\n<ul>\n<li>\n<p>Context Switching (CPU에서 여러 프로세스를 돌아가면서 작업을 처리) 과정에서 캐쉬 메모리 초기화 등 무거운 작업이 진행되고 많은 시간이 소모됨</p>\n<ul>\n<li>프로세스는 각각 독립된 메모리 영역 할당 받음 ⇒ 프로세스 사이에서 공유하는 메모리 없음. Context Switching 발생 시 캐쉬에 있는 데이터 모두 리셋하고 다시 불러와야함</li>\n<li>Context Switching : 동작 중인 프로세스가 대기를 하면서 해당 프로세스의 상태를 보관하고, 대기 하고 있던 다음 프로세스가 동작하면서 이전에 보관했던 프로세스의 상태를 복구하는 작업</li>\n</ul>\n</li>\n<li>\n<p>프로세스 사이의 어렵고 복잡한 통신 기법</p>\n<ul>\n<li>프로세스 사이의 변수 직접적 공유 불가</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"멀티-스레딩\" style=\"position:relative;\"><a href=\"#%EB%A9%80%ED%8B%B0-%EC%8A%A4%EB%A0%88%EB%94%A9\" aria-label=\"멀티 스레딩 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>멀티 스레딩</h3>\n<ul>\n<li>하나의 응용프로그램을 여러 개의 스레드로 구성, 각 스레드로 하여금 하나의 작업을 처리하도록 하는 것</li>\n<li>웹 서버 ⇒ 대표적인 멀티 스레드 응용 프로그램</li>\n<li>\n<p>장점</p>\n<ul>\n<li>시스템 자원 소모 감소 : 프로세스를 생성하여 자원을 할당받는 시스템 콜이 줄어듦</li>\n<li>\n<p>시스템 처리량 증가 (처리 비용 감소)</p>\n<ul>\n<li>스레드 간 데이터를 주고 받는 것이 간단해지고 시스템 자원 소모 줄어듦</li>\n<li>스레드 사이의 작업량이 작아 Context Switching 이 빠르다</li>\n<li>⇒ 프로세스 간의 Context Switching시 단순히 CPU 레지스터 교체 뿐만 아니라 RAM과 CPU 사이의 캐쉬 메모리에 대한 데이터까지 초기화되므로 오버헤드가 큼</li>\n</ul>\n</li>\n<li>\n<p>간단한 통신 방법으로 프로그램 응답 시간 단축</p>\n<ul>\n<li>스레드끼리 프로세스 내의 stack영역을 제외한 모든 메모리 공유 ⇒ 통신 부담 적음</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>단점</p>\n<ul>\n<li>주의깊은 설계 필요</li>\n<li>디버깅 어려움</li>\n<li>단일 프로세스 시스템의 경우 효과 기대하기 어렵다</li>\n<li>다른 프로세스에서 스레드 제어 불가</li>\n<li>멀티 스레드의 경우 자원 공유의 문제</li>\n</ul>\n</li>\n</ul>","fields":{"slug":"/posts/process-vs-thread","tagSlugs":["/tag/os/","/tag/cs/"]},"frontmatter":{"date":"2020-08-24T22:40:32.169Z","description":"프로세스 vs 쓰레드, 개념과 차이점","tags":["OS","CS"],"title":"Process vs. Thread","socialImage":""}}},"pageContext":{"slug":"/posts/process-vs-thread"}},"staticQueryHashes":["251939775","2703480616","401334301"]}
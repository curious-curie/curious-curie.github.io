{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/computed-vs-watch-vs-methods","result":{"data":{"markdownRemark":{"id":"c661fc78-c39e-576b-ae79-dd6a5c6ef45b","html":"<h1 id=\"computed-vs-watch-vs-methods\" style=\"position:relative;\"><a href=\"#computed-vs-watch-vs-methods\" aria-label=\"computed vs watch vs methods permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>computed vs watch vs methods</h1>\n<ul>\n<li>\n<p>computed: 참조하는 데이터의 변화 있을 때만 연산, 한번 연산한 값을 캐싱해놓았다가 필요한 부분에 닷 ㅣ활용</p>\n<ul>\n<li>computed에서 참조하는 속성과 관련없는 것이 업데이트되어서 ui가 재렌더링될 때, computed property는 계산되지 않고 캐싱되어있던 데이터가 리턴됨</li>\n</ul>\n<p>⇒ 종속 대상에 따라 저장된다</p>\n<p>이런 식으로 아무 곳에도 의존하지 않는 속성의 경우 절대로 업데이트 되지 않음</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\">computed<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function-variable function\">now</span><span class=\"token operator\">:</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> Date<span class=\"token punctuation\">.</span><span class=\"token function\">now</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>같은 연산 여러번 반복할 때 효율적</li>\n<li>DOM에서 템플릿 표현식을 통해 참조되지 않으면 계산되지 않는다고 함 (데이터 값이 변경되어도)</li>\n</ul>\n</li>\n<li>methods: 캐싱의 개념 없어 매번 재랜더링</li>\n<li>\n<p>watch: 데이터 변화 감지하여 특정 로직 수행</p>\n<ul>\n<li>데이터 호출과 같이 시간이 상대적으로 더 많이 소모되는 비동기 처리에 적합</li>\n</ul>\n</li>\n</ul>\n<p>상태를 변경하고 싶다면 computed를, 그 이상의 부수 효과를 처리하고 싶으면 watch를 쓰자</p>\n<blockquote>\n<p>Vue는 watch 옵션을 통해 데이터 변경에 반응하는 보다 일반적인 방법을 제공합니다. 이는 데이터 변경에 대한 응답으로 비동기식 또는 시간이 많이 소요되는 조작을 수행하려는 경우에 가장 유용합니다.이는 데이터 변경에 대한 응답으로 비동기식 또는 시간이 많이 소요되는 조작을 수행하려는 경우에 가장 유용합니다.</p>\n</blockquote>\n<p><a href=\"https://ui.toast.com/weekly-pick/ko_20190307/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://ui.toast.com/weekly-pick/ko_20190307/</a></p>\n<p>이때 부수효과란, 직접 컴포넌트에 영향을 주지 않는 </p>\n<ul>\n<li>데이터 가져오거나</li>\n<li>DOM 조작</li>\n<li>로컬 저장소나 브라우저 API 사용</li>\n</ul>","fields":{"slug":"/posts/computed-vs-watch-vs-methods","tagSlugs":["/tag/javascript/","/tag/vue/","/tag/web-development/"]},"frontmatter":{"date":"2020-04-17T22:40:32.169Z","description":"computed vs watch vs methods - 차이점 그리고 언제 써야할까?","tags":["Javascript","Vue","Web Development"],"title":"[Vue.js] computed vs watch vs methods","socialImage":""}}},"pageContext":{"slug":"/posts/computed-vs-watch-vs-methods"}},"staticQueryHashes":["251939775","2703480616","401334301"]}